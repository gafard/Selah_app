import 'package:flutter/foundation.dart';
import 'package:flutter_local_notifications/flutter_local_notifications.dart';
import 'package:timezone/timezone.dart' as tz;
import 'dart:io';

/// üß† Contexte de notification intelligent
class NotificationContext {
  final String? planId;
  final String? readingReference;
  final String? theme;
  final Map<String, dynamic>? metadata;
  
  NotificationContext({
    this.planId,
    this.readingReference,
    this.theme,
    this.metadata,
  });
}

/// üß† Contenu intelligent pour notifications
class IntelligentContent {
  final String title;
  final String body;
  
  IntelligentContent({
    required this.title,
    required this.body,
  });
}

/// üß† PROPH√àTE - Service de notifications avec contexte Thompson
/// 
/// Niveau : Proph√®te (Intelligent) - Service intelligent pour les notifications contextuelles
/// 
/// Priorit√©s d'interaction :
/// üî• Priorit√© 1: thompson_plan_service.dart (th√®mes spirituels)
/// üî• Priorit√© 2: intelligent_local_preset_generator.dart (contexte)
/// üî• Priorit√© 3: meditation_journal_service.dart (historique)
/// üéØ Thompson: Enrichit les messages avec th√®mes spirituels
class NotificationService {
  NotificationService._();
  static final NotificationService instance = NotificationService._();

  final _fln = FlutterLocalNotificationsPlugin();

  Future<void> init() async {
    const androidInit = AndroidInitializationSettings('@mipmap/ic_launcher');
    const iosInit = DarwinInitializationSettings();
    const initSettings = InitializationSettings(android: androidInit, iOS: iosInit);
    await _fln.initialize(initSettings);

    if (!kIsWeb && Platform.isAndroid) {
      await _fln
          .resolvePlatformSpecificImplementation<AndroidFlutterLocalNotificationsPlugin>()
          ?.createNotificationChannel(const AndroidNotificationChannel(
            'selah_daily',
            'Rappels quotidiens',
            description: 'Notifications de m√©ditation/pri√®re Selah',
            importance: Importance.high,
          ));
    }
  }

  /// üß† Affiche une notification intelligente avec contexte Thompson
  Future<void> showNow({
    int id = 1001,
    String? title,
    String? body,
    NotificationContext? context,
  }) async {
    // üß† INTELLIGENCE CONTEXTUELLE - G√©n√©rer contenu intelligent
    final intelligentContent = await _generateIntelligentContent(context);
    
    final finalTitle = title ?? intelligentContent.title;
    final finalBody = body ?? intelligentContent.body;
    
    const android = AndroidNotificationDetails(
      'selah_daily',
      'Rappels quotidiens intelligents',
      importance: Importance.high,
      priority: Priority.high,
      category: AndroidNotificationCategory.reminder,
      styleInformation: BigTextStyleInformation(''),
    );
    const ios = DarwinNotificationDetails(
      interruptionLevel: InterruptionLevel.active,
      categoryIdentifier: 'INTELLIGENT_REMINDER',
    );
    await _fln.show(id, finalTitle, finalBody, const NotificationDetails(android: android, iOS: ios));
    
    print('üèéÔ∏è Proph√®te Intelligent: Notification contextuelle envoy√©e');
  }

  /// üß† G√©n√®re du contenu intelligent bas√© sur le contexte
  Future<IntelligentContent> _generateIntelligentContent(NotificationContext? context) async {
    try {
      // üî• PRIORIT√â 1: R√©cup√©rer le th√®me Thompson
      final thompsonTheme = await _getThompsonTheme(context);
      
      // üî• PRIORIT√â 2: R√©cup√©rer le contexte de lecture
      final readingContext = await _getReadingContext(context);
      
      // üî• PRIORIT√â 3: Analyser l'historique de m√©ditation
      final meditationHistory = await _getMeditationHistory();
      
      return IntelligentContent(
        title: _generateContextualTitle(thompsonTheme, readingContext),
        body: _generateContextualBody(thompsonTheme, readingContext, meditationHistory),
      );
      
    } catch (e) {
      print('‚ö†Ô∏è Erreur g√©n√©ration contenu intelligent: $e');
      return IntelligentContent(
        title: 'Selah',
        body: 'C\'est l\'heure de ta m√©ditation ‚ú®',
      );
    }
  }

  /// üî• PRIORIT√â 1: R√©cup√®re le th√®me Thompson pour le contexte
  Future<String?> _getThompsonTheme(NotificationContext? context) async {
    try {
      if (context?.planId != null) {
        // TODO: Int√©grer avec thompson_plan_service pour r√©cup√©rer le th√®me du plan
        return 'Exigence spirituelle ‚Äî Transformation profonde';
      }
      
      // TODO: R√©cup√©rer le th√®me du jour selon le plan actif
      return 'Vie de pri√®re ‚Äî Souffle spirituel';
    } catch (e) {
      return null;
    }
  }

  /// üî• PRIORIT√â 2: R√©cup√®re le contexte de lecture
  Future<String?> _getReadingContext(NotificationContext? context) async {
    try {
      if (context?.readingReference != null) {
        // TODO: Int√©grer avec semantic_passage_boundary_service pour enrichir le contexte
        return 'Lecture: ${context!.readingReference}';
      }
      
      // TODO: R√©cup√©rer la lecture du jour depuis le plan actif
      return 'Lecture du jour: Psaumes 23';
    } catch (e) {
      return null;
    }
  }

  /// üî• PRIORIT√â 3: Analyse l'historique de m√©ditation
  Future<String?> _getMeditationHistory() async {
    try {
      // TODO: Int√©grer avec meditation_journal_service pour analyser l'historique
      return 'Continue ton parcours spirituel';
    } catch (e) {
      return null;
    }
  }

  /// üéØ G√©n√®re un titre contextuel avec Thompson
  String _generateContextualTitle(String? thompsonTheme, String? readingContext) {
    if (thompsonTheme != null) {
      return thompsonTheme;
    }
    return 'Selah';
  }

  /// üß† G√©n√®re un corps contextuel intelligent
  String _generateContextualBody(String? thompsonTheme, String? readingContext, String? meditationHistory) {
    final parts = <String>[];
    
    if (readingContext != null) {
      parts.add(readingContext);
    }
    
    if (thompsonTheme != null) {
      parts.add('Th√®me: ${thompsonTheme.split(' ‚Äî ').last}');
    }
    
    if (meditationHistory != null) {
      parts.add(meditationHistory);
    }
    
    if (parts.isEmpty) {
      return 'C\'est l\'heure de ta m√©ditation ‚ú®';
    }
    
    return parts.join('\n\n');
  }

  Future<void> cancel(int id) => _fln.cancel(id);

  Future<void> zonedDaily({
    required int id,
    required String title,
    required String body,
    required NotificationDetails details,
    required tz.TZDateTime scheduledDate,
  }) async {
    await _fln.zonedSchedule(
      id,
      title,
      body,
      scheduledDate,
      details,
      uiLocalNotificationDateInterpretation:
          UILocalNotificationDateInterpretation.wallClockTime,
      androidAllowWhileIdle: true,
      matchDateTimeComponents: DateTimeComponents.time, // tous les jours m√™me heure
    );
  }
}