import 'package:intl/intl.dart';
import '../models/plan_day.dart';
import 'local_storage_service.dart';

/// Service de rattrapage intelligent pour les jours manqu√©s
/// 
/// Fonctionnalit√©s :
/// 1. D√©tecte automatiquement les jours manqu√©s
/// 2. Marque comme "skipped" les jours pass√©s non compl√©t√©s
/// 3. Recale le calendrier pour rattraper
/// 4. Propose des options de rattrapage flexibles
/// 
/// Modes de rattrapage :
/// - CATCH_UP : Ajoute les jours manqu√©s √† la fin
/// - RESCHEDULE : D√©cale tout le planning
/// - SKIP : Ignore les jours manqu√©s et continue
/// - FLEXIBLE : Mix intelligent selon contexte
class PlanCatchupService {
  
  /// V√©rifie si des jours ont √©t√© manqu√©s pour un plan
  /// 
  /// [planId] : ID du plan
  /// [planDays] : Liste compl√®te des jours du plan
  /// 
  /// Retourne : Liste des jours manqu√©s
  static List<PlanDay> detectMissedDays({
    required String planId,
    required List<PlanDay> planDays,
  }) {
    final today = DateTime.now();
    final missedDays = <PlanDay>[];
    
    for (final day in planDays) {
      // Si le jour est dans le pass√© et pas compl√©t√© ‚Üí manqu√©
      if (day.date.isBefore(today) && 
          day.status == PlanDayStatus.pending) {
        missedDays.add(day);
      }
    }
    
    if (missedDays.isNotEmpty) {
      print('‚ö†Ô∏è ${missedDays.length} jour(s) manqu√©(s) d√©tect√©(s) pour le plan $planId');
    }
    
    return missedDays;
  }
  
  /// Marque les jours manqu√©s comme "skipped"
  /// 
  /// [planId] : ID du plan
  /// [missedDays] : Liste des jours manqu√©s
  /// 
  /// Retourne : Nombre de jours marqu√©s
  static Future<int> markMissedDaysAsSkipped({
    required String planId,
    required List<PlanDay> missedDays,
  }) async {
    int markedCount = 0;
    
    for (final day in missedDays) {
      try {
        // R√©cup√©rer la progression actuelle
        final progress = LocalStorageService.getDayProgress(planId, day.dayNumber) ?? {};
        
        // Marquer comme skipped
        progress['status'] = 'skipped';
        progress['skipped_at'] = DateTime.now().toIso8601String();
        progress['reason'] = 'auto_detected_missed';
        
        // Sauvegarder
        await LocalStorageService.saveDayProgress(planId, day.dayNumber, progress);
        
        markedCount++;
      } catch (e) {
        print('‚ö†Ô∏è Erreur marquage jour ${day.dayNumber}: $e');
      }
    }
    
    print('‚úÖ $markedCount jour(s) marqu√©(s) comme skipped');
    return markedCount;
  }
  
  /// Recale le calendrier du plan selon le mode de rattrapage
  /// 
  /// [planId] : ID du plan
  /// [planDays] : Liste compl√®te des jours
  /// [missedDays] : Jours manqu√©s
  /// [mode] : Mode de rattrapage
  /// 
  /// Retourne : Liste des jours recal√©s
  static Future<List<PlanDay>> reschedule({
    required String planId,
    required List<PlanDay> planDays,
    required List<PlanDay> missedDays,
    required CatchupMode mode,
  }) async {
    print('üîÑ Recalage du calendrier (mode: ${mode.name})...');
    
    switch (mode) {
      case CatchupMode.catchUp:
        return await _catchUpMode(planId, planDays, missedDays);
        
      case CatchupMode.reschedule:
        return await _rescheduleMode(planId, planDays);
        
      case CatchupMode.skip:
        return await _skipMode(planId, planDays, missedDays);
        
      case CatchupMode.flexible:
        return await _flexibleMode(planId, planDays, missedDays);
    }
  }
  
  /// Mode CATCH_UP : Ajoute les jours manqu√©s √† la fin du plan
  static Future<List<PlanDay>> _catchUpMode(
    String planId,
    List<PlanDay> planDays,
    List<PlanDay> missedDays,
  ) async {
    print('  üìÖ Mode CATCH_UP: Ajout de ${missedDays.length} jour(s) √† la fin');
    
    // 1. Marquer les jours manqu√©s
    await markMissedDaysAsSkipped(planId: planId, missedDays: missedDays);
    
    // 2. Trouver la date de fin actuelle
    final lastDay = planDays.last;
    var nextDate = lastDay.date.add(Duration(days: 1));
    
    // 3. Ajouter les jours manqu√©s √† la fin
    final catchupDays = <PlanDay>[];
    for (final missedDay in missedDays) {
      final newDay = PlanDay(
        id: '${planId}_catchup_${missedDay.dayNumber}',
        planId: planId,
        dayNumber: planDays.length + catchupDays.length + 1,
        date: nextDate,
        bibleReferences: missedDay.bibleReferences,
        status: PlanDayStatus.pending,
        isCatchup: true, // Marqueur sp√©cial
        originalDayNumber: missedDay.dayNumber,
      );
      
      catchupDays.add(newDay);
      nextDate = nextDate.add(Duration(days: 1));
    }
    
    print('  ‚úÖ ${catchupDays.length} jour(s) de rattrapage ajout√©s');
    return [...planDays, ...catchupDays];
  }
  
  /// Mode RESCHEDULE : D√©cale tous les jours restants
  static Future<List<PlanDay>> _rescheduleMode(
    String planId,
    List<PlanDay> planDays,
  ) async {
    print('  üìÖ Mode RESCHEDULE: D√©calage de tous les jours restants');
    
    final today = DateTime.now();
    final rescheduled = <PlanDay>[];
    var currentDate = today;
    
    for (final day in planDays) {
      // Si d√©j√† compl√©t√©, garder tel quel
      if (day.status == PlanDayStatus.completed) {
        rescheduled.add(day);
        continue;
      }
      
      // Si dans le pass√© et non compl√©t√©, marquer skipped
      if (day.date.isBefore(today)) {
        final skippedDay = day.copyWith(
          status: PlanDayStatus.skipped,
        );
        rescheduled.add(skippedDay);
        
        // Sauvegarder le statut
        final progress = LocalStorageService.getDayProgress(planId, day.dayNumber) ?? {};
        progress['status'] = 'skipped';
        await LocalStorageService.saveDayProgress(planId, day.dayNumber, progress);
        continue;
      }
      
      // Recaler les jours futurs
      final rescheduledDay = day.copyWith(
        date: currentDate,
      );
      rescheduled.add(rescheduledDay);
      currentDate = currentDate.add(Duration(days: 1));
    }
    
    print('  ‚úÖ Planning recal√© (nouveau dernier jour: ${DateFormat('dd/MM/yyyy').format(currentDate)})');
    return rescheduled;
  }
  
  /// Mode SKIP : Ignore les jours manqu√©s et continue normalement
  static Future<List<PlanDay>> _skipMode(
    String planId,
    List<PlanDay> planDays,
    List<PlanDay> missedDays,
  ) async {
    print('  üìÖ Mode SKIP: Ignorer ${missedDays.length} jour(s) manqu√©(s)');
    
    // Simplement marquer comme skipped
    await markMissedDaysAsSkipped(planId: planId, missedDays: missedDays);
    
    // Retourner le plan tel quel
    return planDays.map((day) {
      final isMissed = missedDays.any((m) => m.dayNumber == day.dayNumber);
      return isMissed ? day.copyWith(status: PlanDayStatus.skipped) : day;
    }).toList();
  }
  
  /// Mode FLEXIBLE : Mix intelligent selon le contexte
  static Future<List<PlanDay>> _flexibleMode(
    String planId,
    List<PlanDay> planDays,
    List<PlanDay> missedDays,
  ) async {
    print('  üìÖ Mode FLEXIBLE: Analyse intelligente...');
    
    final missedCount = missedDays.length;
    final totalDays = planDays.length;
    final missedPercentage = (missedCount / totalDays * 100).round();
    
    // Logique intelligente
    if (missedPercentage <= 10) {
      // < 10% manqu√© ‚Üí Catch up (peu de jours √† rattraper)
      print('    ‚Üí ${missedPercentage}% manqu√©s ‚Üí Mode CATCH_UP');
      return await _catchUpMode(planId, planDays, missedDays);
    } else if (missedPercentage <= 30) {
      // 10-30% manqu√© ‚Üí Reschedule (trop pour catch up)
      print('    ‚Üí ${missedPercentage}% manqu√©s ‚Üí Mode RESCHEDULE');
      return await _rescheduleMode(planId, planDays);
    } else {
      // > 30% manqu√© ‚Üí Skip (plan probablement abandonn√©)
      print('    ‚Üí ${missedPercentage}% manqu√©s ‚Üí Mode SKIP (plan √† risque)');
      return await _skipMode(planId, planDays, missedDays);
    }
  }
  
  /// Analyse le plan et propose le meilleur mode de rattrapage
  /// 
  /// [planId] : ID du plan
  /// [planDays] : Liste des jours
  /// 
  /// Retourne : Mode recommand√© avec justification
  static CatchupRecommendation analyzePlan({
    required String planId,
    required List<PlanDay> planDays,
  }) {
    final missedDays = detectMissedDays(planId: planId, planDays: planDays);
    
    if (missedDays.isEmpty) {
      return CatchupRecommendation(
        mode: CatchupMode.skip,
        reason: 'Aucun jour manqu√© - Plan √† jour',
        missedCount: 0,
        affectedDays: 0,
      );
    }
    
    final totalDays = planDays.length;
    final missedCount = missedDays.length;
    final missedPercentage = (missedCount / totalDays * 100).round();
    
    // Calculer la s√©rie de jours manqu√©s cons√©cutifs
    final consecutiveMissed = _countConsecutiveMissed(missedDays);
    
    // Analyse intelligente
    if (missedPercentage <= 10 && consecutiveMissed <= 3) {
      return CatchupRecommendation(
        mode: CatchupMode.catchUp,
        reason: 'Peu de jours manqu√©s ($missedPercentage%) - Rattrapage facile',
        missedCount: missedCount,
        affectedDays: missedCount,
      );
    } else if (missedPercentage <= 30 || consecutiveMissed > 5) {
      return CatchupRecommendation(
        mode: CatchupMode.reschedule,
        reason: 'Plusieurs jours manqu√©s ($missedPercentage%) - Recalage recommand√©',
        missedCount: missedCount,
        affectedDays: totalDays - planDays.where((d) => d.status == PlanDayStatus.completed).length,
      );
    } else {
      return CatchupRecommendation(
        mode: CatchupMode.skip,
        reason: 'Trop de jours manqu√©s ($missedPercentage%) - Envisager un nouveau plan',
        missedCount: missedCount,
        affectedDays: 0,
      );
    }
  }
  
  /// Compte le nombre de jours manqu√©s cons√©cutifs (max)
  static int _countConsecutiveMissed(List<PlanDay> missedDays) {
    if (missedDays.isEmpty) return 0;
    
    // Trier par date
    final sorted = [...missedDays]..sort((a, b) => a.date.compareTo(b.date));
    
    int maxConsecutive = 1;
    int currentConsecutive = 1;
    
    for (int i = 1; i < sorted.length; i++) {
      final diff = sorted[i].date.difference(sorted[i - 1].date).inDays;
      
      if (diff == 1) {
        // Cons√©cutif
        currentConsecutive++;
        maxConsecutive = max(maxConsecutive, currentConsecutive);
      } else {
        // Rupture
        currentConsecutive = 1;
      }
    }
    
    return maxConsecutive;
  }
  
  /// Applique automatiquement le rattrapage au d√©marrage de l'app
  /// 
  /// [planId] : ID du plan actif
  /// [planDays] : Liste des jours
  /// 
  /// Retourne : true si rattrapage effectu√©
  static Future<bool> autoApplyCatchup({
    required String planId,
    required List<PlanDay> planDays,
  }) async {
    print('üîç V√©rification automatique du rattrapage...');
    
    final missedDays = detectMissedDays(planId: planId, planDays: planDays);
    
    if (missedDays.isEmpty) {
      print('  ‚úÖ Aucun jour manqu√©');
      return false;
    }
    
    // Analyser et appliquer
    final recommendation = analyzePlan(planId: planId, planDays: planDays);
    
    print('  üìã Recommandation: ${recommendation.mode.name}');
    print('  üí° Raison: ${recommendation.reason}');
    
    // Appliquer automatiquement en mode flexible
    await reschedule(
      planId: planId,
      planDays: planDays,
      missedDays: missedDays,
      mode: CatchupMode.flexible,
    );
    
    return true;
  }
  
  /// G√©n√®re un rapport de rattrapage pour l'utilisateur
  /// 
  /// [planId] : ID du plan
  /// [planDays] : Liste des jours
  /// 
  /// Retourne : Rapport lisible
  static CatchupReport generateReport({
    required String planId,
    required List<PlanDay> planDays,
  }) {
    final missedDays = detectMissedDays(planId: planId, planDays: planDays);
    final recommendation = analyzePlan(planId: planId, planDays: planDays);
    
    final completedDays = planDays.where((d) => d.status == PlanDayStatus.completed).length;
    final skippedDays = planDays.where((d) => d.status == PlanDayStatus.skipped).length;
    final pendingDays = planDays.where((d) => d.status == PlanDayStatus.pending).length;
    
    final completionRate = (completedDays / planDays.length * 100).round();
    final missedRate = (missedDays.length / planDays.length * 100).round();
    
    return CatchupReport(
      planId: planId,
      totalDays: planDays.length,
      completedDays: completedDays,
      skippedDays: skippedDays,
      pendingDays: pendingDays,
      missedDays: missedDays.length,
      completionRate: completionRate,
      missedRate: missedRate,
      recommendation: recommendation,
      message: _generateMessage(completionRate, missedRate, missedDays.length),
    );
  }
  
  /// G√©n√®re un message d'encouragement/action
  static String _generateMessage(int completionRate, int missedRate, int missedCount) {
    if (missedCount == 0) {
      return 'üéâ Excellent ! Vous √™tes √† jour dans votre plan.';
    } else if (missedRate <= 10) {
      return 'üí™ Bon rythme ! Rattrapez les $missedCount jour(s) manqu√©s pour rester sur la bonne voie.';
    } else if (missedRate <= 30) {
      return '‚ö†Ô∏è Attention ! $missedCount jours manqu√©s. Recalez votre planning pour continuer sereinement.';
    } else {
      return 'üîÑ Plan en difficult√©. Envisagez de recommencer un nouveau plan adapt√© √† votre rythme actuel.';
    }
  }
}

/// Modes de rattrapage
enum CatchupMode {
  catchUp,    // Ajouter les jours manqu√©s √† la fin
  reschedule, // D√©caler tout le planning
  skip,       // Ignorer les jours manqu√©s
  flexible,   // Mode intelligent (auto)
}

/// Recommandation de rattrapage
class CatchupRecommendation {
  final CatchupMode mode;
  final String reason;
  final int missedCount;
  final int affectedDays;
  
  CatchupRecommendation({
    required this.mode,
    required this.reason,
    required this.missedCount,
    required this.affectedDays,
  });
  
  @override
  String toString() {
    return 'Mode: ${mode.name}\nRaison: $reason\nJours manqu√©s: $missedCount\nJours affect√©s: $affectedDays';
  }
}

/// Rapport de rattrapage
class CatchupReport {
  final String planId;
  final int totalDays;
  final int completedDays;
  final int skippedDays;
  final int pendingDays;
  final int missedDays;
  final int completionRate;
  final int missedRate;
  final CatchupRecommendation recommendation;
  final String message;
  
  CatchupReport({
    required this.planId,
    required this.totalDays,
    required this.completedDays,
    required this.skippedDays,
    required this.pendingDays,
    required this.missedDays,
    required this.completionRate,
    required this.missedRate,
    required this.recommendation,
    required this.message,
  });
  
  /// Retourne un r√©sum√© format√©
  String get summary {
    return '''
üìä R√©sum√© du plan:
‚Ä¢ Total: $totalDays jours
‚Ä¢ Compl√©t√©s: $completedDays ($completionRate%)
‚Ä¢ Manqu√©s: $missedDays ($missedRate%)
‚Ä¢ En attente: $pendingDays

${recommendation.toString()}

$message
''';
  }
}

/// Extension pour PlanDay
extension PlanDayExtension on PlanDay {
  /// Cr√©e une copie avec modifications
  PlanDay copyWith({
    String? id,
    String? planId,
    int? dayNumber,
    DateTime? date,
    List<String>? bibleReferences,
    PlanDayStatus? status,
    bool? isCatchup,
    int? originalDayNumber,
  }) {
    return PlanDay(
      id: id ?? this.id,
      planId: planId ?? this.planId,
      dayNumber: dayNumber ?? this.dayNumber,
      date: date ?? this.date,
      bibleReferences: bibleReferences ?? this.bibleReferences,
      status: status ?? this.status,
      isCatchup: isCatchup ?? (this.isCatchup ?? false),
      originalDayNumber: originalDayNumber ?? this.originalDayNumber,
    );
  }
}

