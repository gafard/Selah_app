/// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
/// PLAN SERVICE - Moteur unique de gÃ©nÃ©ration de plans
/// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
///
/// Architecture unifiÃ©e :
/// - 1 moteur partagÃ© (_buildPlanWithSharedEngine)
/// - 2 points d'entrÃ©e (createFromPreset, createCustom)
/// - Pipeline complet : BookSelector â†’ Duration â†’ ReadingSizer â†’ Semantic â†’ Calendar â†’ Scoring â†’ Save
///
/// Avantages :
/// âœ… CohÃ©rence : MÃªme logique pour preset et custom
/// âœ… Maintenance : Une amÃ©lioration profite aux deux
/// âœ… Offline : 100% local (Hive), sync BG si rÃ©seau
/// âœ… Ã‰volutivitÃ© : Extensible (units JSON, rÃ¨gles, scoring)
/// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
library plan_service;

import 'package:hive/hive.dart';
import '../models/plan.dart';
import '../models/plan_preset.dart';
import '../models/user_profile.dart';
import 'intelligent_duration_calculator.dart';
import 'intelligent_motivation.dart';
import 'preset_behavioral_scorer.dart';
import 'semantic_passage_boundary_service_v2.dart';
import 'reading_sizer.dart';
import 'chapter_index_loader.dart';
import 'intelligent_prayer_generator.dart';
import 'stable_random_service.dart';

/// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
/// CRITÃˆRES UNIFIÃ‰S - Normalise entrÃ©es preset OU custom
/// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class Criteria {
  final DateTime startDate;
  final List<int> daysOfWeek; // 1=Lun, 2=Mar, ..., 7=Dim
  final int minutesPerDay;
  final Map<String, dynamic> profile; // goal, level, posture, motivation
  final List<String> books; // Livres sÃ©lectionnÃ©s
  final String order; // 'traditional', 'chronological', 'thematic'
  final String? presetId; // Si vient d'un preset
  final String? presetName; // Si vient d'un preset
  final Map<String, dynamic>? options; // Options UI supplÃ©mentaires

  const Criteria({
    required this.startDate,
    required this.daysOfWeek,
    required this.minutesPerDay,
    required this.profile,
    required this.books,
    required this.order,
    this.presetId,
    this.presetName,
    this.options,
  });

  /// Depuis un preset
  factory Criteria.fromPreset(
    PlanPreset preset,
    Map<String, dynamic> profile,
    Map<String, dynamic>? options,
  ) {
    // Normaliser les livres (peut Ãªtre "GenÃ¨se,Exode" ou liste)
    final raw = preset.books;
    final list = (raw is List)
        ? raw.cast<String>()
        : raw.toString().split(',').map((s) => s.trim()).where((s) => s.isNotEmpty).toList();

    return Criteria(
      startDate: options?['startDate'] ?? DateTime.now(),
      daysOfWeek: _parseDaysOfWeek(options?['daysOfWeek']),
      minutesPerDay: options?['minutesPerDay'] ?? preset.minutesPerDay ?? 15,
      profile: profile,
      books: list,
      order: options?['order'] as String? ?? 'traditional',
      presetId: preset.slug,
      presetName: preset.name,
      options: options,
    );
  }

  /// Depuis formulaire custom
  factory Criteria.fromCustom(
    Map<String, dynamic> form,
    Map<String, dynamic> profile,
  ) {
    return Criteria(
      startDate: form['startDate'] ?? DateTime.now(),
      daysOfWeek: _parseDaysOfWeek(form['daysOfWeek']),
      minutesPerDay: form['minutesPerDay'] ?? 15,
      profile: profile,
      books: (form['books'] as List?)?.cast<String>() ?? [],
      order: form['order'] ?? 'traditional',
      presetId: null,
      presetName: null,
      options: form,
    );
  }

  static List<int> _parseDaysOfWeek(dynamic days) {
    if (days == null) return [1, 2, 3, 4, 5]; // Lun-Ven par dÃ©faut
    if (days is List<int>) return days;
    if (days is List) return days.cast<int>();
    return [1, 2, 3, 4, 5];
  }
}

/// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
/// PLAN SERVICE - Service principal
/// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class PlanService {
  /// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  /// POINTS D'ENTRÃ‰E PUBLICS (2)
  /// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  /// 1) CrÃ©er plan depuis une carte preset
  static Future<Plan> createFromPreset(
    PlanPreset preset,
    Map<String, dynamic> profile,
    Map<String, dynamic>? options,
  ) async {
    print('ğŸ“– CrÃ©ation plan depuis preset: ${preset.name}');

    final criteria = Criteria.fromPreset(preset, profile, options);

    return _buildPlanWithSharedEngine(criteria);
  }

  /// 2) CrÃ©er plan depuis formulaire custom
  static Future<Plan> createCustom(
    Map<String, dynamic> form,
    Map<String, dynamic> profile,
  ) async {
    print('ğŸ¨ CrÃ©ation plan personnalisÃ©');

    final criteria = Criteria.fromCustom(form, profile);

    return _buildPlanWithSharedEngine(criteria);
  }

  /// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  /// MOTEUR PARTAGÃ‰ (Pipeline complet)
  /// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  static Future<Plan> _buildPlanWithSharedEngine(Criteria c) async {
    print('ğŸ”§ DÃ©marrage moteur partagÃ©...');

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // Ã‰TAPE 1 : SÃ©lection des livres (preset OU custom)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    final booksPool = await _selectBooks(c);
    print('ğŸ“š Livres sÃ©lectionnÃ©s: ${booksPool.map((b) => b.name).join(', ')}');

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // Ã‰TAPE 2 : Calcul durÃ©e & intensitÃ© cibles
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    final durationCalc = IntelligentDurationCalculator.calculateOptimalDuration(
      goal: c.profile['goal'] ?? 'Discipline quotidienne',
      level: c.profile['level'] ?? 'FidÃ¨le rÃ©gulier',
      dailyMinutes: c.minutesPerDay,
      meditationType: c.profile['meditation'],
    );

    print('â±ï¸  DurÃ©e optimale: ${durationCalc.optimalDays} jours');
    print('ğŸ’¡ Reasoning: ${durationCalc.reasoning}');

    // Appliquer motivation/posture multipliers
    final motivation = c.profile['motivation'] as String? ?? 'consistent';
    final adjustedDuration = IntelligentMotivation.adjustDuration(
      durationCalc.optimalDays,
      motivation,
    );

    print('ğŸ”¥ DurÃ©e ajustÃ©e (motivation): $adjustedDuration jours');

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // Ã‰TAPE 3 : Index chapitres (Hive)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    // ChapterIndexLoader dÃ©jÃ  hydratÃ© au boot
    // VÃ©rifier disponibilitÃ©
    for (final book in booksPool) {
      if (!ChapterIndexLoader.isBookLoaded(book.name)) {
        print('âš ï¸  ${book.name} pas dans ChapterIndex, utilisation fallback');
      }
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // Ã‰TAPE 4 : GÃ©nÃ©ration passages bruts (chapitrage)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    final rawPassages = await _generateRawPassages(
      booksPool: booksPool,
      targetDays: adjustedDuration,
      minutesPerDay: c.minutesPerDay,
    );

    print('ğŸ“„ Passages bruts gÃ©nÃ©rÃ©s: ${rawPassages.length} jours');

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // Ã‰TAPE 5 : Ajustement sÃ©mantique (respect unitÃ©s littÃ©raires)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    final boundedPassages = await _applySemanticBoundaries(rawPassages);

    final adjustedCount = boundedPassages.where((p) => p.wasAdjusted).length;
    print('âœ… Passages ajustÃ©s sÃ©mantiquement: $adjustedCount/${boundedPassages.length}');

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // Ã‰TAPE 6 : Planification calendrier (startDate + daysOfWeek)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    final scheduledDays = await _scheduleToCalendar(
      passages: boundedPassages,
      startDate: c.startDate,
      daysOfWeek: c.daysOfWeek,
    );

    print('ğŸ“… Jours planifiÃ©s: ${scheduledDays.length}');

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // Ã‰TAPE 7 : Scoring comportemental + Enrichissements
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    final enrichedDays = await _enrichWithMetadata(
      days: scheduledDays,
      profile: c.profile,
      booksPool: booksPool,
    );

    print('ğŸ’ MÃ©tadonnÃ©es enrichies');

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // Ã‰TAPE 8 : Assemblage plan final
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    final plan = await _assemblePlan(
      criteria: c,
      days: enrichedDays,
      durationCalc: durationCalc,
      booksPool: booksPool,
    );

    print('ğŸ“¦ Plan assemblÃ©: ${plan.id}');

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // Ã‰TAPE 9 : Persistance (Hive) + Sync queue
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    await _savePlan(plan);

    print('ğŸ’¾ Plan sauvegardÃ© (Hive)');

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // Ã‰TAPE 10 : Notifications rappels
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    await _scheduleNotifications(plan);

    print('ğŸ”” Notifications planifiÃ©es');

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // Ã‰TAPE 11 : TÃ©lÃ©mÃ©trie (optionnel)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    _logPlanCreated(plan, c);

    print('âœ… Plan crÃ©Ã© avec succÃ¨s: ${plan.id}');

    return plan;
  }

  /// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  /// HELPERS INTERNES (Pipeline steps)
  /// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  /// Ã‰TAPE 1 : SÃ©lection livres
  static Future<List<BookInfo>> _selectBooks(Criteria c) async {
    final books = <BookInfo>[];

    for (final bookName in c.books) {
      // RÃ©cupÃ©rer mÃ©tadonnÃ©es livre
      final totalChapters = await _getBookChapterCount(bookName);

      books.add(BookInfo(
        name: bookName,
        totalChapters: totalChapters,
        order: c.order,
      ));
    }

    // Filtres posture/motivation (si actifs)
    // TODO: ImplÃ©menter filtres avancÃ©s

    return books;
  }

  /// Ã‰TAPE 4 : GÃ©nÃ©ration passages bruts
  static Future<List<RawPassage>> _generateRawPassages({
    required List<BookInfo> booksPool,
    required int targetDays,
    required int minutesPerDay,
  }) async {
    final allPassages = <RawPassage>[];
    int globalDayNumber = 1;

    for (final book in booksPool) {
      // Utiliser ReadingSizer pour ce livre
      final bookPassages = ReadingSizer.generateReadingPlan(
        book: book.name,
        totalChapters: book.totalChapters,
        targetMinutesPerDay: minutesPerDay.toDouble(),
      );

      // Convertir en RawPassage
      for (final passage in bookPassages) {
        allPassages.add(RawPassage(
          globalDayNumber: globalDayNumber,
          book: passage['book'] as String,
          startChapter: passage['startChapter'] as int,
          endChapter: passage['endChapter'] as int,
          estimatedMinutes: passage['approxMinutes'] as int,
          reference: passage['range'] as String,
        ));

        globalDayNumber++;
      }
    }

    return allPassages;
  }

  /// Ã‰TAPE 5 : Ajustement sÃ©mantique
  static Future<List<BoundedPassage>> _applySemanticBoundaries(
    List<RawPassage> rawPassages,
  ) async {
    final bounded = <BoundedPassage>[];

    for (final raw in rawPassages) {
      // Ajuster avec SÃ©mantique v2
      final adjusted = SemanticPassageBoundaryService.adjustPassageVerses(
        book: raw.book,
        startChapter: raw.startChapter,
        startVerse: 1,
        endChapter: raw.endChapter,
        endVerse: ChapterIndexLoader.verseCount(raw.book, raw.endChapter),
      );

      // RÃ©-estimer temps aprÃ¨s ajustement
      final finalMinutes = ChapterIndexLoader.estimateMinutesRange(
        book: adjusted.book,
        startChapter: adjusted.startChapter,
        endChapter: adjusted.endChapter,
      );

      bounded.add(BoundedPassage(
        globalDayNumber: raw.globalDayNumber,
        book: adjusted.book,
        startChapter: adjusted.startChapter,
        startVerse: adjusted.startVerse,
        endChapter: adjusted.endChapter,
        endVerse: adjusted.endVerse,
        reference: adjusted.reference,
        estimatedMinutes: finalMinutes,
        wasAdjusted: adjusted.adjusted,
        annotation: adjusted.includedUnit?.name,
        unitType: adjusted.includedUnit?.type.name,
        unitPriority: adjusted.includedUnit?.priority.name,
      ));
    }

    return bounded;
  }

  /// Ã‰TAPE 6 : Planification calendrier
  static Future<List<ScheduledDay>> _scheduleToCalendar({
    required List<BoundedPassage> passages,
    required DateTime startDate,
    required List<int> daysOfWeek,
  }) async {
    final scheduled = <ScheduledDay>[];
    DateTime currentDate = startDate;
    int passageIndex = 0;

    while (passageIndex < passages.length) {
      // Trouver le prochain jour valide
      while (!daysOfWeek.contains(currentDate.weekday)) {
        currentDate = currentDate.add(const Duration(days: 1));
      }

      // Assigner passage Ã  ce jour
      final passage = passages[passageIndex];

      scheduled.add(ScheduledDay(
        dayNumber: passageIndex + 1,
        date: currentDate,
        passage: passage,
      ));

      currentDate = currentDate.add(const Duration(days: 1));
      passageIndex++;
    }

    return scheduled;
  }

  /// Ã‰TAPE 7 : Enrichissement mÃ©tadonnÃ©es
  static Future<List<EnrichedDay>> _enrichWithMetadata({
    required List<ScheduledDay> days,
    required Map<String, dynamic> profile,
    required List<BookInfo> booksPool,
  }) async {
    final enriched = <EnrichedDay>[];

    for (final day in days) {
      // GÃ©nÃ©rer priÃ¨re personnalisÃ©e
      final prayer = await _generatePrayer(
        passage: day.passage,
        profile: profile,
        dayNumber: day.dayNumber,
      );

      // Ajouter mÃ©tadonnÃ©es
      enriched.add(EnrichedDay(
        scheduledDay: day,
        prayerSuggestion: prayer.text,
        meditationQuestions: prayer.questions,
        tags: _generateTags(day.passage),
        meditationType: _inferMeditationType(day.passage),
      ));
    }

    return enriched;
  }

  /// Ã‰TAPE 8 : Assemblage plan
  static Future<Plan> _assemblePlan({
    required Criteria criteria,
    required List<EnrichedDay> days,
    required DurationCalculation durationCalc,
    required List<BookInfo> booksPool,
  }) async {
    final planId = _generatePlanId();

    // Utiliser le modÃ¨le Plan simple (models/plan.dart)
    return Plan(
      id: planId,
      name: criteria.presetName ?? _generateCustomTitle(booksPool),
      startDate: criteria.startDate,
      totalDays: days.length,
      coverUrl: null,
    );
  }

  /// Ã‰TAPE 9 : Persistance
  static Future<void> _savePlan(Plan plan) async {
    final box = await Hive.openBox('local_plans');
    await box.put(plan.id, plan.toJson());

    // Enqueue sync si rÃ©seau disponible
    await _enqueuSync(plan);
  }

  /// Ã‰TAPE 10 : Notifications
  static Future<void> _scheduleNotifications(Plan plan) async {
    // TODO: ImplÃ©menter NotificationService
    // for (final day in plan.days) {
    //   await NotificationService.schedule(
    //     id: '${plan.id}_${day.dayNumber}',
    //     date: day.date,
    //     title: 'Lecture du jour',
    //     body: day.reference,
    //   );
    // }
  }

  /// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  /// HELPERS PRIVÃ‰S
  /// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  static Future<int> _getBookChapterCount(String bookName) async {
    // Chercher dans ChapterIndex ou fallback
    final box = Hive.box('chapter_index');

    // Compter combien de chapitres chargÃ©s
    int count = 1;
    while (box.containsKey('$bookName:$count')) {
      count++;
    }

    // Si aucun trouvÃ©, utiliser fallback basÃ© sur livre
    if (count == 1) {
      return _fallbackChapterCount(bookName);
    }

    return count - 1;
  }

  static int _fallbackChapterCount(String bookName) {
    // Fallback basÃ© sur connaissance biblique
    const counts = {
      'GenÃ¨se': 50, 'Exode': 40, 'LÃ©vitique': 27,
      'Matthieu': 28, 'Marc': 16, 'Luc': 24, 'Jean': 21,
      'Romains': 16, 'Psaumes': 150,
      // ... (ajouter selon besoin)
    };

    return counts[bookName] ?? 25; // Fallback gÃ©nÃ©ral
  }

  static Future<Prayer> _generatePrayer({
    required BoundedPassage passage,
    required Map<String, dynamic> profile,
    required int dayNumber,
  }) async {
    // Seed stable basÃ© sur dayNumber pour reproductibilitÃ©
    // final seed = StableRandomService.getSeed('prayer_$dayNumber');

    // GÃ©nÃ©rer priÃ¨re (Ã  implÃ©menter selon votre systÃ¨me existant)
    // final context = PrayerContext(...);
    // return IntelligentPrayerGenerator.generate(context);

    // Stub temporaire
    return Prayer(
      text: 'Seigneur, ouvre mon cÅ“ur Ã  ${passage.reference}',
      questions: [],
    );
  }

  static List<String> _generateTags(BoundedPassage passage) {
    final tags = <String>[];

    if (passage.annotation != null) {
      tags.add(passage.unitType ?? 'passage');
    }

    // Ajouter tags basÃ©s sur livre
    // TODO: Enrichir avec ThemesService

    return tags;
  }

  static String? _inferMeditationType(BoundedPassage passage) {
    if (passage.unitType == null) return null;

    switch (passage.unitType) {
      case 'discourse':
        return 'enseignement';
      case 'parable':
        return 'contemplation';
      case 'narrative':
        return 'imaginative';
      case 'poetry':
        return 'affective';
      case 'argument':
        return 'analytique';
      default:
        return 'libre';
    }
  }

  static String _generatePlanId() {
    return 'plan_${DateTime.now().millisecondsSinceEpoch}';
  }

  static String _generateCustomTitle(List<BookInfo> books) {
    if (books.length == 1) {
      return 'Plan ${books.first.name}';
    }
    return 'Plan personnalisÃ© (${books.length} livres)';
  }

  static String _generateDescription(List<BookInfo> books, int totalDays) {
    if (books.length == 1) {
      return 'Lecture de ${books.first.name} en $totalDays jours';
    }
    return 'Lecture de ${books.map((b) => b.name).join(', ')} en $totalDays jours';
  }

  static Future<void> _enqueuSync(Plan plan) async {
    final queue = await Hive.openBox('sync_queue');
    await queue.add({
      'type': 'plan_created',
      'planId': plan.id,
      'timestamp': DateTime.now().toIso8601String(),
      'data': plan.toJson(),
    });
  }

  static void _logPlanCreated(Plan plan, Criteria c) {
    // TODO: ImplÃ©menter TelemetryService
    print('ğŸ“Š TÃ©lÃ©mÃ©trie: plan_created');
    // TelemetryService.event('plan_created', {
    //   'planId': plan.id,
    //   'source': c.presetId != null ? 'preset' : 'custom',
    //   'books': c.books,
    //   'duration': plan.duration,
    //   'minutesPerDay': c.minutesPerDay,
    // });
  }
}

/// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
/// MODELS INTERNES
/// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class BookInfo {
  final String name;
  final int totalChapters;
  final String order;

  const BookInfo({
    required this.name,
    required this.totalChapters,
    required this.order,
  });

  Map<String, dynamic> toJson() => {
        'name': name,
        'totalChapters': totalChapters,
        'order': order,
      };
}

class RawPassage {
  final int globalDayNumber;
  final String book;
  final int startChapter;
  final int endChapter;
  final int estimatedMinutes;
  final String reference;

  const RawPassage({
    required this.globalDayNumber,
    required this.book,
    required this.startChapter,
    required this.endChapter,
    required this.estimatedMinutes,
    required this.reference,
  });
}

class BoundedPassage {
  final int globalDayNumber;
  final String book;
  final int startChapter;
  final int startVerse;
  final int endChapter;
  final int endVerse;
  final String reference;
  final int estimatedMinutes;
  final bool wasAdjusted;
  final String? annotation;
  final String? unitType;
  final String? unitPriority;

  const BoundedPassage({
    required this.globalDayNumber,
    required this.book,
    required this.startChapter,
    required this.startVerse,
    required this.endChapter,
    required this.endVerse,
    required this.reference,
    required this.estimatedMinutes,
    required this.wasAdjusted,
    this.annotation,
    this.unitType,
    this.unitPriority,
  });
}

class ScheduledDay {
  final int dayNumber;
  final DateTime date;
  final BoundedPassage passage;

  const ScheduledDay({
    required this.dayNumber,
    required this.date,
    required this.passage,
  });
}

class EnrichedDay {
  final ScheduledDay scheduledDay;
  final String prayerSuggestion;
  final List<String> meditationQuestions;
  final List<String> tags;
  final String? meditationType;

  const EnrichedDay({
    required this.scheduledDay,
    required this.prayerSuggestion,
    required this.meditationQuestions,
    required this.tags,
    this.meditationType,
  });
}

class Prayer {
  final String text;
  final List<String> questions;

  const Prayer({
    required this.text,
    required this.questions,
  });
}
