/// ═══════════════════════════════════════════════════════════════════════════
/// PLAN SERVICE - Moteur unique de génération de plans
/// ═══════════════════════════════════════════════════════════════════════════
///
/// Architecture unifiée :
/// - 1 moteur partagé (_buildPlanWithSharedEngine)
/// - 2 points d'entrée (createFromPreset, createCustom)
/// - Pipeline complet : BookSelector → Duration → ReadingSizer → Semantic → Calendar → Scoring → Save
///
/// Avantages :
/// ✅ Cohérence : Même logique pour preset et custom
/// ✅ Maintenance : Une amélioration profite aux deux
/// ✅ Offline : 100% local (Hive), sync BG si réseau
/// ✅ Évolutivité : Extensible (units JSON, règles, scoring)
/// ═══════════════════════════════════════════════════════════════════════════
library plan_service;

import 'package:hive/hive.dart';
import '../models/plan.dart';
import '../models/plan_preset.dart';
import '../models/user_profile.dart';
import 'intelligent_duration_calculator.dart';
import 'intelligent_motivation.dart';
import 'preset_behavioral_scorer.dart';
import 'semantic_passage_boundary_service_v2.dart';
import 'reading_sizer.dart';
import 'chapter_index_loader.dart';
import 'intelligent_prayer_generator.dart';
import 'stable_random_service.dart';

/// ═══════════════════════════════════════════════════════════════════════════
/// CRITÈRES UNIFIÉS - Normalise entrées preset OU custom
/// ═══════════════════════════════════════════════════════════════════════════

class Criteria {
  final DateTime startDate;
  final List<int> daysOfWeek; // 1=Lun, 2=Mar, ..., 7=Dim
  final int minutesPerDay;
  final Map<String, dynamic> profile; // goal, level, posture, motivation
  final List<String> books; // Livres sélectionnés
  final String order; // 'traditional', 'chronological', 'thematic'
  final String? presetId; // Si vient d'un preset
  final String? presetName; // Si vient d'un preset
  final Map<String, dynamic>? options; // Options UI supplémentaires

  const Criteria({
    required this.startDate,
    required this.daysOfWeek,
    required this.minutesPerDay,
    required this.profile,
    required this.books,
    required this.order,
    this.presetId,
    this.presetName,
    this.options,
  });

  /// Depuis un preset
  factory Criteria.fromPreset(
    PlanPreset preset,
    Map<String, dynamic> profile,
    Map<String, dynamic>? options,
  ) {
    // Normaliser les livres (peut être "Genèse,Exode" ou liste)
    final raw = preset.books;
    final list = (raw is List)
        ? raw.cast<String>()
        : raw.toString().split(',').map((s) => s.trim()).where((s) => s.isNotEmpty).toList();

    return Criteria(
      startDate: options?['startDate'] ?? DateTime.now(),
      daysOfWeek: _parseDaysOfWeek(options?['daysOfWeek']),
      minutesPerDay: options?['minutesPerDay'] ?? preset.minutesPerDay ?? 15,
      profile: profile,
      books: list,
      order: options?['order'] as String? ?? 'traditional',
      presetId: preset.slug,
      presetName: preset.name,
      options: options,
    );
  }

  /// Depuis formulaire custom
  factory Criteria.fromCustom(
    Map<String, dynamic> form,
    Map<String, dynamic> profile,
  ) {
    return Criteria(
      startDate: form['startDate'] ?? DateTime.now(),
      daysOfWeek: _parseDaysOfWeek(form['daysOfWeek']),
      minutesPerDay: form['minutesPerDay'] ?? 15,
      profile: profile,
      books: (form['books'] as List?)?.cast<String>() ?? [],
      order: form['order'] ?? 'traditional',
      presetId: null,
      presetName: null,
      options: form,
    );
  }

  static List<int> _parseDaysOfWeek(dynamic days) {
    if (days == null) return [1, 2, 3, 4, 5]; // Lun-Ven par défaut
    if (days is List<int>) return days;
    if (days is List) return days.cast<int>();
    return [1, 2, 3, 4, 5];
  }
}

/// ═══════════════════════════════════════════════════════════════════════════
/// PLAN SERVICE - Service principal
/// ═══════════════════════════════════════════════════════════════════════════

class PlanService {
  /// ═══════════════════════════════════════════════════════════════════════
  /// POINTS D'ENTRÉE PUBLICS (2)
  /// ═══════════════════════════════════════════════════════════════════════

  /// 1) Créer plan depuis une carte preset
  static Future<Plan> createFromPreset(
    PlanPreset preset,
    Map<String, dynamic> profile,
    Map<String, dynamic>? options,
  ) async {
    print('📖 Création plan depuis preset: ${preset.name}');

    final criteria = Criteria.fromPreset(preset, profile, options);

    return _buildPlanWithSharedEngine(criteria);
  }

  /// 2) Créer plan depuis formulaire custom
  static Future<Plan> createCustom(
    Map<String, dynamic> form,
    Map<String, dynamic> profile,
  ) async {
    print('🎨 Création plan personnalisé');

    final criteria = Criteria.fromCustom(form, profile);

    return _buildPlanWithSharedEngine(criteria);
  }

  /// ═══════════════════════════════════════════════════════════════════════
  /// MOTEUR PARTAGÉ (Pipeline complet)
  /// ═══════════════════════════════════════════════════════════════════════

  static Future<Plan> _buildPlanWithSharedEngine(Criteria c) async {
    print('🔧 Démarrage moteur partagé...');

    // ═══════════════════════════════════════════════════════════════════════
    // ÉTAPE 1 : Sélection des livres (preset OU custom)
    // ═══════════════════════════════════════════════════════════════════════

    final booksPool = await _selectBooks(c);
    print('📚 Livres sélectionnés: ${booksPool.map((b) => b.name).join(', ')}');

    // ═══════════════════════════════════════════════════════════════════════
    // ÉTAPE 2 : Calcul durée & intensité cibles
    // ═══════════════════════════════════════════════════════════════════════

    final durationCalc = IntelligentDurationCalculator.calculateOptimalDuration(
      goal: c.profile['goal'] ?? 'Discipline quotidienne',
      level: c.profile['level'] ?? 'Fidèle régulier',
      dailyMinutes: c.minutesPerDay,
      meditationType: c.profile['meditation'],
    );

    print('⏱️  Durée optimale: ${durationCalc.optimalDays} jours');
    print('💡 Reasoning: ${durationCalc.reasoning}');

    // Appliquer motivation/posture multipliers
    final motivation = c.profile['motivation'] as String? ?? 'consistent';
    final adjustedDuration = IntelligentMotivation.adjustDuration(
      durationCalc.optimalDays,
      motivation,
    );

    print('🔥 Durée ajustée (motivation): $adjustedDuration jours');

    // ═══════════════════════════════════════════════════════════════════════
    // ÉTAPE 3 : Index chapitres (Hive)
    // ═══════════════════════════════════════════════════════════════════════

    // ChapterIndexLoader déjà hydraté au boot
    // Vérifier disponibilité
    for (final book in booksPool) {
      if (!ChapterIndexLoader.isBookLoaded(book.name)) {
        print('⚠️  ${book.name} pas dans ChapterIndex, utilisation fallback');
      }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // ÉTAPE 4 : Génération passages bruts (chapitrage)
    // ═══════════════════════════════════════════════════════════════════════

    final rawPassages = await _generateRawPassages(
      booksPool: booksPool,
      targetDays: adjustedDuration,
      minutesPerDay: c.minutesPerDay,
    );

    print('📄 Passages bruts générés: ${rawPassages.length} jours');

    // ═══════════════════════════════════════════════════════════════════════
    // ÉTAPE 5 : Ajustement sémantique (respect unités littéraires)
    // ═══════════════════════════════════════════════════════════════════════

    final boundedPassages = await _applySemanticBoundaries(rawPassages);

    final adjustedCount = boundedPassages.where((p) => p.wasAdjusted).length;
    print('✅ Passages ajustés sémantiquement: $adjustedCount/${boundedPassages.length}');

    // ═══════════════════════════════════════════════════════════════════════
    // ÉTAPE 6 : Planification calendrier (startDate + daysOfWeek)
    // ═══════════════════════════════════════════════════════════════════════

    final scheduledDays = await _scheduleToCalendar(
      passages: boundedPassages,
      startDate: c.startDate,
      daysOfWeek: c.daysOfWeek,
    );

    print('📅 Jours planifiés: ${scheduledDays.length}');

    // ═══════════════════════════════════════════════════════════════════════
    // ÉTAPE 7 : Scoring comportemental + Enrichissements
    // ═══════════════════════════════════════════════════════════════════════

    final enrichedDays = await _enrichWithMetadata(
      days: scheduledDays,
      profile: c.profile,
      booksPool: booksPool,
    );

    print('💎 Métadonnées enrichies');

    // ═══════════════════════════════════════════════════════════════════════
    // ÉTAPE 8 : Assemblage plan final
    // ═══════════════════════════════════════════════════════════════════════

    final plan = await _assemblePlan(
      criteria: c,
      days: enrichedDays,
      durationCalc: durationCalc,
      booksPool: booksPool,
    );

    print('📦 Plan assemblé: ${plan.id}');

    // ═══════════════════════════════════════════════════════════════════════
    // ÉTAPE 9 : Persistance (Hive) + Sync queue
    // ═══════════════════════════════════════════════════════════════════════

    await _savePlan(plan);

    print('💾 Plan sauvegardé (Hive)');

    // ═══════════════════════════════════════════════════════════════════════
    // ÉTAPE 10 : Notifications rappels
    // ═══════════════════════════════════════════════════════════════════════

    await _scheduleNotifications(plan);

    print('🔔 Notifications planifiées');

    // ═══════════════════════════════════════════════════════════════════════
    // ÉTAPE 11 : Télémétrie (optionnel)
    // ═══════════════════════════════════════════════════════════════════════

    _logPlanCreated(plan, c);

    print('✅ Plan créé avec succès: ${plan.id}');

    return plan;
  }

  /// ═══════════════════════════════════════════════════════════════════════
  /// HELPERS INTERNES (Pipeline steps)
  /// ═══════════════════════════════════════════════════════════════════════

  /// ÉTAPE 1 : Sélection livres
  static Future<List<BookInfo>> _selectBooks(Criteria c) async {
    final books = <BookInfo>[];

    for (final bookName in c.books) {
      // Récupérer métadonnées livre
      final totalChapters = await _getBookChapterCount(bookName);

      books.add(BookInfo(
        name: bookName,
        totalChapters: totalChapters,
        order: c.order,
      ));
    }

    // Filtres posture/motivation (si actifs)
    // TODO: Implémenter filtres avancés

    return books;
  }

  /// ÉTAPE 4 : Génération passages bruts
  static Future<List<RawPassage>> _generateRawPassages({
    required List<BookInfo> booksPool,
    required int targetDays,
    required int minutesPerDay,
  }) async {
    final allPassages = <RawPassage>[];
    int globalDayNumber = 1;

    for (final book in booksPool) {
      // Utiliser ReadingSizer pour ce livre
      final bookPassages = ReadingSizer.generateReadingPlan(
        book: book.name,
        totalChapters: book.totalChapters,
        targetMinutesPerDay: minutesPerDay.toDouble(),
      );

      // Convertir en RawPassage
      for (final passage in bookPassages) {
        allPassages.add(RawPassage(
          globalDayNumber: globalDayNumber,
          book: passage['book'] as String,
          startChapter: passage['startChapter'] as int,
          endChapter: passage['endChapter'] as int,
          estimatedMinutes: passage['approxMinutes'] as int,
          reference: passage['range'] as String,
        ));

        globalDayNumber++;
      }
    }

    return allPassages;
  }

  /// ÉTAPE 5 : Ajustement sémantique
  static Future<List<BoundedPassage>> _applySemanticBoundaries(
    List<RawPassage> rawPassages,
  ) async {
    final bounded = <BoundedPassage>[];

    for (final raw in rawPassages) {
      // Ajuster avec Sémantique v2
      final adjusted = SemanticPassageBoundaryService.adjustPassageVerses(
        book: raw.book,
        startChapter: raw.startChapter,
        startVerse: 1,
        endChapter: raw.endChapter,
        endVerse: ChapterIndexLoader.verseCount(raw.book, raw.endChapter),
      );

      // Ré-estimer temps après ajustement
      final finalMinutes = ChapterIndexLoader.estimateMinutesRange(
        book: adjusted.book,
        startChapter: adjusted.startChapter,
        endChapter: adjusted.endChapter,
      );

      bounded.add(BoundedPassage(
        globalDayNumber: raw.globalDayNumber,
        book: adjusted.book,
        startChapter: adjusted.startChapter,
        startVerse: adjusted.startVerse,
        endChapter: adjusted.endChapter,
        endVerse: adjusted.endVerse,
        reference: adjusted.reference,
        estimatedMinutes: finalMinutes,
        wasAdjusted: adjusted.adjusted,
        annotation: adjusted.includedUnit?.name,
        unitType: adjusted.includedUnit?.type.name,
        unitPriority: adjusted.includedUnit?.priority.name,
      ));
    }

    return bounded;
  }

  /// ÉTAPE 6 : Planification calendrier
  static Future<List<ScheduledDay>> _scheduleToCalendar({
    required List<BoundedPassage> passages,
    required DateTime startDate,
    required List<int> daysOfWeek,
  }) async {
    final scheduled = <ScheduledDay>[];
    DateTime currentDate = startDate;
    int passageIndex = 0;

    while (passageIndex < passages.length) {
      // Trouver le prochain jour valide
      while (!daysOfWeek.contains(currentDate.weekday)) {
        currentDate = currentDate.add(const Duration(days: 1));
      }

      // Assigner passage à ce jour
      final passage = passages[passageIndex];

      scheduled.add(ScheduledDay(
        dayNumber: passageIndex + 1,
        date: currentDate,
        passage: passage,
      ));

      currentDate = currentDate.add(const Duration(days: 1));
      passageIndex++;
    }

    return scheduled;
  }

  /// ÉTAPE 7 : Enrichissement métadonnées
  static Future<List<EnrichedDay>> _enrichWithMetadata({
    required List<ScheduledDay> days,
    required Map<String, dynamic> profile,
    required List<BookInfo> booksPool,
  }) async {
    final enriched = <EnrichedDay>[];

    for (final day in days) {
      // Générer prière personnalisée
      final prayer = await _generatePrayer(
        passage: day.passage,
        profile: profile,
        dayNumber: day.dayNumber,
      );

      // Ajouter métadonnées
      enriched.add(EnrichedDay(
        scheduledDay: day,
        prayerSuggestion: prayer.text,
        meditationQuestions: prayer.questions,
        tags: _generateTags(day.passage),
        meditationType: _inferMeditationType(day.passage),
      ));
    }

    return enriched;
  }

  /// ÉTAPE 8 : Assemblage plan
  static Future<Plan> _assemblePlan({
    required Criteria criteria,
    required List<EnrichedDay> days,
    required DurationCalculation durationCalc,
    required List<BookInfo> booksPool,
  }) async {
    final planId = _generatePlanId();

    // Utiliser le modèle Plan simple (models/plan.dart)
    return Plan(
      id: planId,
      name: criteria.presetName ?? _generateCustomTitle(booksPool),
      startDate: criteria.startDate,
      totalDays: days.length,
      coverUrl: null,
    );
  }

  /// ÉTAPE 9 : Persistance
  static Future<void> _savePlan(Plan plan) async {
    final box = await Hive.openBox('local_plans');
    await box.put(plan.id, plan.toJson());

    // Enqueue sync si réseau disponible
    await _enqueuSync(plan);
  }

  /// ÉTAPE 10 : Notifications
  static Future<void> _scheduleNotifications(Plan plan) async {
    // TODO: Implémenter NotificationService
    // for (final day in plan.days) {
    //   await NotificationService.schedule(
    //     id: '${plan.id}_${day.dayNumber}',
    //     date: day.date,
    //     title: 'Lecture du jour',
    //     body: day.reference,
    //   );
    // }
  }

  /// ═══════════════════════════════════════════════════════════════════════
  /// HELPERS PRIVÉS
  /// ═══════════════════════════════════════════════════════════════════════

  static Future<int> _getBookChapterCount(String bookName) async {
    // Chercher dans ChapterIndex ou fallback
    final box = Hive.box('chapter_index');

    // Compter combien de chapitres chargés
    int count = 1;
    while (box.containsKey('$bookName:$count')) {
      count++;
    }

    // Si aucun trouvé, utiliser fallback basé sur livre
    if (count == 1) {
      return _fallbackChapterCount(bookName);
    }

    return count - 1;
  }

  static int _fallbackChapterCount(String bookName) {
    // Fallback basé sur connaissance biblique
    const counts = {
      'Genèse': 50, 'Exode': 40, 'Lévitique': 27,
      'Matthieu': 28, 'Marc': 16, 'Luc': 24, 'Jean': 21,
      'Romains': 16, 'Psaumes': 150,
      // ... (ajouter selon besoin)
    };

    return counts[bookName] ?? 25; // Fallback général
  }

  static Future<Prayer> _generatePrayer({
    required BoundedPassage passage,
    required Map<String, dynamic> profile,
    required int dayNumber,
  }) async {
    // Seed stable basé sur dayNumber pour reproductibilité
    // final seed = StableRandomService.getSeed('prayer_$dayNumber');

    // Générer prière (à implémenter selon votre système existant)
    // final context = PrayerContext(...);
    // return IntelligentPrayerGenerator.generate(context);

    // Stub temporaire
    return Prayer(
      text: 'Seigneur, ouvre mon cœur à ${passage.reference}',
      questions: [],
    );
  }

  static List<String> _generateTags(BoundedPassage passage) {
    final tags = <String>[];

    if (passage.annotation != null) {
      tags.add(passage.unitType ?? 'passage');
    }

    // Ajouter tags basés sur livre
    // TODO: Enrichir avec ThemesService

    return tags;
  }

  static String? _inferMeditationType(BoundedPassage passage) {
    if (passage.unitType == null) return null;

    switch (passage.unitType) {
      case 'discourse':
        return 'enseignement';
      case 'parable':
        return 'contemplation';
      case 'narrative':
        return 'imaginative';
      case 'poetry':
        return 'affective';
      case 'argument':
        return 'analytique';
      default:
        return 'libre';
    }
  }

  static String _generatePlanId() {
    return 'plan_${DateTime.now().millisecondsSinceEpoch}';
  }

  static String _generateCustomTitle(List<BookInfo> books) {
    if (books.length == 1) {
      return 'Plan ${books.first.name}';
    }
    return 'Plan personnalisé (${books.length} livres)';
  }

  static String _generateDescription(List<BookInfo> books, int totalDays) {
    if (books.length == 1) {
      return 'Lecture de ${books.first.name} en $totalDays jours';
    }
    return 'Lecture de ${books.map((b) => b.name).join(', ')} en $totalDays jours';
  }

  static Future<void> _enqueuSync(Plan plan) async {
    final queue = await Hive.openBox('sync_queue');
    await queue.add({
      'type': 'plan_created',
      'planId': plan.id,
      'timestamp': DateTime.now().toIso8601String(),
      'data': plan.toJson(),
    });
  }

  static void _logPlanCreated(Plan plan, Criteria c) {
    // TODO: Implémenter TelemetryService
    print('📊 Télémétrie: plan_created');
    // TelemetryService.event('plan_created', {
    //   'planId': plan.id,
    //   'source': c.presetId != null ? 'preset' : 'custom',
    //   'books': c.books,
    //   'duration': plan.duration,
    //   'minutesPerDay': c.minutesPerDay,
    // });
  }
}

/// ═══════════════════════════════════════════════════════════════════════════
/// MODELS INTERNES
/// ═══════════════════════════════════════════════════════════════════════════

class BookInfo {
  final String name;
  final int totalChapters;
  final String order;

  const BookInfo({
    required this.name,
    required this.totalChapters,
    required this.order,
  });

  Map<String, dynamic> toJson() => {
        'name': name,
        'totalChapters': totalChapters,
        'order': order,
      };
}

class RawPassage {
  final int globalDayNumber;
  final String book;
  final int startChapter;
  final int endChapter;
  final int estimatedMinutes;
  final String reference;

  const RawPassage({
    required this.globalDayNumber,
    required this.book,
    required this.startChapter,
    required this.endChapter,
    required this.estimatedMinutes,
    required this.reference,
  });
}

class BoundedPassage {
  final int globalDayNumber;
  final String book;
  final int startChapter;
  final int startVerse;
  final int endChapter;
  final int endVerse;
  final String reference;
  final int estimatedMinutes;
  final bool wasAdjusted;
  final String? annotation;
  final String? unitType;
  final String? unitPriority;

  const BoundedPassage({
    required this.globalDayNumber,
    required this.book,
    required this.startChapter,
    required this.startVerse,
    required this.endChapter,
    required this.endVerse,
    required this.reference,
    required this.estimatedMinutes,
    required this.wasAdjusted,
    this.annotation,
    this.unitType,
    this.unitPriority,
  });
}

class ScheduledDay {
  final int dayNumber;
  final DateTime date;
  final BoundedPassage passage;

  const ScheduledDay({
    required this.dayNumber,
    required this.date,
    required this.passage,
  });
}

class EnrichedDay {
  final ScheduledDay scheduledDay;
  final String prayerSuggestion;
  final List<String> meditationQuestions;
  final List<String> tags;
  final String? meditationType;

  const EnrichedDay({
    required this.scheduledDay,
    required this.prayerSuggestion,
    required this.meditationQuestions,
    required this.tags,
    this.meditationType,
  });
}

class Prayer {
  final String text;
  final List<String> questions;

  const Prayer({
    required this.text,
    required this.questions,
  });
}
