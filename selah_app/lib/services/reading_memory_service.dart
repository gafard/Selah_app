import 'package:hive/hive.dart';
import 'semantic_passage_boundary_service.dart';

/// ‚ö° √âVANG√âLISTE - Service de m√©moire de lecture avec intelligence s√©mantique
/// 
/// Niveau : √âvang√©liste (Fonctionnel) - Service fonctionnel pour la m√©moire adaptative
/// 
/// Priorit√©s d'interaction :
/// üî• Priorit√© 1: semantic_passage_boundary_service.dart (contexte s√©mantique)
/// üî• Priorit√© 2: meditation_journal_service.dart (journal spirituel)
/// üî• Priorit√© 3: thompson_plan_service.dart (th√®mes spirituels)
/// üéØ Thompson: Enrichit la m√©moire avec th√®mes spirituels
/// 
/// Fonctionnalit√©s :
/// 1. File "M√©moriser ce passage" ‚Üí Queue de versets √† m√©moriser
/// 2. "Retenu de ma lecture" ‚Üí Ce que l'utilisateur a retenu aujourd'hui
/// 3. Proposition Poster en fin de pri√®re
/// 4. üß† INTELLIGENCE: Analyse s√©mantique des passages m√©moris√©s
/// 5. üß† INTELLIGENCE: Suggestions bas√©es sur le contexte Thompson
/// 
/// Box Hive : 'reading_mem'
/// 
/// Structure :
/// {
///   'memory_queue': [
///     {id: "Jean.3.16", note: "Verset central", date: "ISO8601", semantic_context: {...}, ...}
///   ],
///   'retentions': [
///     {id: "Luc.15.32", retained: "Dieu cherche les perdus", date: "ISO8601", thompson_theme: "...", ...}
///   ]
/// }
class ReadingMemoryService {
  static Box? _memBox;
  
  /// Initialise la box Hive
  static Future<void> init() async {
    _memBox = await Hive.openBox('reading_mem');
    print('‚úÖ ReadingMemoryService initialis√©');
  }
  
  /// üß† Ajoute un verset √† la queue de m√©morisation avec contexte s√©mantique
  /// 
  /// [id] : ID du verset (ex: "Jean.3.16")
  /// [note] : Note optionnelle ("Pourquoi je veux m√©moriser?")
  /// 
  /// D√©clench√©e depuis le menu contextuel "M√©moriser ce passage"
  static Future<void> queueMemoryVerse(String id, {String? note}) async {
    try {
      final queue = _getMemoryQueue();
      
      // V√©rifier si d√©j√† dans la queue
      final exists = queue.any((item) => item['id'] == id);
      if (exists) {
        print('  ‚ö†Ô∏è Verset $id d√©j√† dans la queue de m√©morisation');
        return;
      }
      
      // üß† INTELLIGENCE CONTEXTUELLE - R√©cup√©rer le contexte s√©mantique
      final semanticContext = await _getSemanticContext(id);
      
      // üß† INTELLIGENCE CONTEXTUELLE - R√©cup√©rer le th√®me Thompson
      final thompsonTheme = await _getThompsonTheme(id);
      
      // Ajouter √† la queue avec contexte enrichi
      queue.add({
        'id': id,
        'note': note,
        'date_added': DateTime.now().toIso8601String(),
        'status': 'pending', // pending, memorized, dismissed
        'semantic_context': semanticContext,
        'thompson_theme': thompsonTheme,
        'priority_score': _calculatePriorityScore(semanticContext, thompsonTheme),
      });
      
      await _memBox?.put('memory_queue', queue);
      print('üöó √âvang√©liste Intelligent: Verset $id ajout√© avec contexte s√©mantique');
    } catch (e) {
      print('‚ùå Erreur queueMemoryVerse($id): $e');
    }
  }

  /// üî• PRIORIT√â 1: R√©cup√®re le contexte s√©mantique FALCON X
  static Future<Map<String, dynamic>?> _getSemanticContext(String id) async {
    try {
      // Extraire livre et chapitre de l'ID
      final parts = id.split('.');
      if (parts.length < 2) return null;
      
      final book = parts[0];
      final chapter = int.tryParse(parts[1]);
      if (chapter == null) return null;
      
      // Utiliser FALCON X pour trouver l'unit√© s√©mantique
      final unit = SemanticPassageBoundaryService.findUnitContaining(book, chapter);
      if (unit == null) return null;
      
      return {
        'unit_name': unit.name,
        'priority': unit.priority.name,
        'theme': unit.theme,
        'liturgical_context': unit.liturgicalContext,
        'emotional_tones': unit.emotionalTones,
        'annotation': unit.annotation,
      };
    } catch (e) {
      return null;
    }
  }

  /// üî• PRIORIT√â 3: R√©cup√®re le th√®me Thompson
  static Future<String?> _getThompsonTheme(String id) async {
    try {
      // TODO: Int√©grer avec thompson_plan_service pour r√©cup√©rer le th√®me
      // Mapping basique pour l'instant
      final book = id.split('.').first;
      
      if (book.contains('Psaumes')) {
        return 'Vie de pri√®re ‚Äî Souffle spirituel';
      } else if (book.contains('Jean')) {
        return 'Exigence spirituelle ‚Äî Transformation profonde';
      } else if (book.contains('Matthieu')) {
        return 'Ne vous inqui√©tez pas ‚Äî Apprentissages de Mt 6';
      }
      
      return null;
    } catch (e) {
      return null;
    }
  }

  /// üß† Calcule un score de priorit√© pour la m√©morisation
  static double _calculatePriorityScore(Map<String, dynamic>? semantic, String? thompson) {
    double score = 0.5; // Score de base
    
    if (semantic != null) {
      final priority = semantic['priority'] as String?;
      if (priority == 'critical') {
        score += 0.3; // Priorit√© haute pour les passages critiques
      } else if (priority == 'high') {
        score += 0.2;
      } else if (priority == 'medium') {
        score += 0.1;
      }
    }
    
    if (thompson != null) {
      if (thompson.contains('pri√®re') || thompson.contains('sagesse')) {
        score += 0.2; // Bonus pour les th√®mes spirituels importants
      }
    }
    
    return score.clamp(0.0, 1.0);
  }
  
  /// üß† Sauvegarde ce que l'utilisateur a retenu avec contexte s√©mantique
  /// 
  /// [id] : ID du verset ou passage
  /// [retained] : Ce que l'utilisateur a retenu (texte libre)
  /// [date] : Date de la lecture
  /// [addToJournal] : Ajouter au journal spirituel
  /// [addToWall] : Publier sur le mur spirituel (local)
  /// 
  /// D√©clench√©e depuis "Marquer comme lu" apr√®s saisie utilisateur
  static Future<void> saveRetention({
    required String id,
    required String retained,
    required DateTime date,
    bool addToJournal = true,
    bool addToWall = false,
  }) async {
    try {
      final retentions = _getRetentions();
      
      // üß† INTELLIGENCE CONTEXTUELLE - R√©cup√©rer le contexte s√©mantique
      final semanticContext = await _getSemanticContext(id);
      
      // üß† INTELLIGENCE CONTEXTUELLE - R√©cup√©rer le th√®me Thompson
      final thompsonTheme = await _getThompsonTheme(id);
      
      // üß† INTELLIGENCE CONTEXTUELLE - Analyser la r√©tention
      final retentionAnalysis = await _analyzeRetention(retained, semanticContext, thompsonTheme);
      
      // Ajouter la nouvelle r√©tention avec contexte enrichi
      retentions.add({
        'id': id,
        'retained': retained,
        'date': date.toIso8601String(),
        'add_to_journal': addToJournal,
        'add_to_wall': addToWall,
        'poster_created': false, // Flag pour proposer Poster plus tard
        'created_at': DateTime.now().toIso8601String(),
        'semantic_context': semanticContext,
        'thompson_theme': thompsonTheme,
        'retention_analysis': retentionAnalysis,
        'emotional_tone': _extractEmotionalTone(retained),
        'spiritual_depth': _calculateSpiritualDepth(retained, semanticContext),
      });
      
      await _memBox?.put('retentions', retentions);
      print('üöó √âvang√©liste Intelligent: R√©tention sauvegard√©e avec analyse s√©mantique pour $id');
      
      // Si addToJournal, d√©clencher aussi la sauvegarde dans le journal
      if (addToJournal) {
        await _saveToJournal(id, retained, date, semanticContext, thompsonTheme);
      }
      
      // Si addToWall, marquer pour publication
      if (addToWall) {
        await _saveToWall(id, retained, date, semanticContext, thompsonTheme);
      }
    } catch (e) {
      print('‚ùå Erreur saveRetention: $e');
    }
  }

  /// üß† Analyse la r√©tention avec contexte s√©mantique
  static Future<Map<String, dynamic>> _analyzeRetention(
    String retained, 
    Map<String, dynamic>? semantic, 
    String? thompson
  ) async {
    try {
      return {
        'word_count': retained.split(' ').length,
        'has_personal_reflection': retained.toLowerCase().contains('je') || retained.toLowerCase().contains('moi'),
        'has_spiritual_terms': _hasSpiritualTerms(retained),
        'semantic_alignment': _calculateSemanticAlignment(retained, semantic),
        'thompson_alignment': _calculateThompsonAlignment(retained, thompson),
        'depth_score': _calculateDepthScore(retained),
      };
    } catch (e) {
      return {};
    }
  }

  /// üß† V√©rifie si la r√©tention contient des termes spirituels
  static bool _hasSpiritualTerms(String text) {
    final spiritualTerms = ['Dieu', 'J√©sus', 'Christ', 'Esprit', 'pri√®re', 'foi', 'amour', 'gr√¢ce', 'saint'];
    final lowerText = text.toLowerCase();
    return spiritualTerms.any((term) => lowerText.contains(term.toLowerCase()));
  }

  /// üß† Calcule l'alignement s√©mantique
  static double _calculateSemanticAlignment(String retained, Map<String, dynamic>? semantic) {
    if (semantic == null) return 0.5;
    
    final theme = semantic['theme'] as String?;
    if (theme == null) return 0.5;
    
    final lowerRetained = retained.toLowerCase();
    final lowerTheme = theme.toLowerCase();
    
    // V√©rifier si la r√©tention contient des mots-cl√©s du th√®me
    if (lowerTheme.contains('pri√®re') && lowerRetained.contains('pri√®re')) return 0.9;
    if (lowerTheme.contains('sagesse') && lowerRetained.contains('sagesse')) return 0.9;
    if (lowerTheme.contains('amour') && lowerRetained.contains('amour')) return 0.9;
    
    return 0.5; // Alignement neutre
  }

  /// üß† Calcule l'alignement Thompson
  static double _calculateThompsonAlignment(String retained, String? thompson) {
    if (thompson == null) return 0.5;
    
    final lowerRetained = retained.toLowerCase();
    final lowerThompson = thompson.toLowerCase();
    
    // V√©rifier si la r√©tention contient des mots-cl√©s du th√®me Thompson
    if (lowerThompson.contains('pri√®re') && lowerRetained.contains('pri√®re')) return 0.9;
    if (lowerThompson.contains('sagesse') && lowerRetained.contains('sagesse')) return 0.9;
    if (lowerThompson.contains('transformation') && lowerRetained.contains('transformation')) return 0.9;
    
    return 0.5; // Alignement neutre
  }

  /// üß† Calcule un score de profondeur spirituelle
  static double _calculateDepthScore(String retained) {
    double score = 0.0;
    
    // Bonus pour la longueur (r√©flexion approfondie)
    final wordCount = retained.split(' ').length;
    if (wordCount > 20) {
      score += 0.3;
    } else if (wordCount > 10) score += 0.2;
    else if (wordCount > 5) score += 0.1;
    
    // Bonus pour les termes spirituels
    if (_hasSpiritualTerms(retained)) score += 0.3;
    
    // Bonus pour les r√©f√©rences personnelles
    if (retained.toLowerCase().contains('je') || retained.toLowerCase().contains('moi')) score += 0.2;
    
    // Bonus pour les questions spirituelles
    if (retained.contains('?')) score += 0.2;
    
    return score.clamp(0.0, 1.0);
  }

  /// üß† Extrait le ton √©motionnel de la r√©tention
  static String _extractEmotionalTone(String retained) {
    final lowerText = retained.toLowerCase();
    
    if (lowerText.contains('joie') || lowerText.contains('heureux') || lowerText.contains('b√©ni')) {
      return 'joyful';
    } else if (lowerText.contains('paix') || lowerText.contains('calme') || lowerText.contains('s√©r√©nit√©')) {
      return 'peaceful';
    } else if (lowerText.contains('gratitude') || lowerText.contains('merci') || lowerText.contains('reconnaissant')) {
      return 'grateful';
    } else if (lowerText.contains('espoir') || lowerText.contains('confiance') || lowerText.contains('foi')) {
      return 'hopeful';
    } else if (lowerText.contains('r√©flexion') || lowerText.contains('m√©ditation') || lowerText.contains('pens√©e')) {
      return 'contemplative';
    }
    
    return 'neutral';
  }

  /// üß† Calcule la profondeur spirituelle
  static double _calculateSpiritualDepth(String retained, Map<String, dynamic>? semantic) {
    double depth = _calculateDepthScore(retained);
    
    // Bonus si le contexte s√©mantique est critique
    if (semantic != null) {
      final priority = semantic['priority'] as String?;
      if (priority == 'critical') {
        depth += 0.2;
      } else if (priority == 'high') {
        depth += 0.1;
      }
    }
    
    return depth.clamp(0.0, 1.0);
  }
  
  /// R√©cup√®re les passages en attente pour cr√©ation de Poster
  /// 
  /// √Ä appeler en fin de pri√®re ou √† l'ouverture de l'app
  /// 
  /// Retourne : Liste des √©l√©ments (m√©morisation + r√©tention) √† proposer
  static Future<List<Map<String, dynamic>>> pendingForPoster() async {
    final pending = <Map<String, dynamic>>[];
    
    try {
      // 1. Versets √† m√©moriser (memory_queue)
      final memoryQueue = _getMemoryQueue();
      for (final item in memoryQueue) {
        if (item['status'] == 'pending') {
          pending.add({
            'type': 'memory',
            'id': item['id'],
            'note': item['note'],
            'date': item['date_added'],
          });
        }
      }
      
      // 2. R√©tentions sans poster cr√©√©
      final retentions = _getRetentions();
      for (final item in retentions) {
        if (item['poster_created'] == false) {
          pending.add({
            'type': 'retention',
            'id': item['id'],
            'retained': item['retained'],
            'date': item['date'],
          });
        }
      }
      
      print('üìã ${pending.length} √©l√©ment(s) en attente pour Poster');
    } catch (e) {
      print('‚ùå Erreur pendingForPoster: $e');
    }
    
    return pending;
  }
  
  /// Marque un √©l√©ment comme "Poster cr√©√©"
  /// 
  /// [id] : ID du verset
  /// [type] : 'memory' ou 'retention'
  static Future<void> markPosterDone(String id, {String type = 'retention'}) async {
    try {
      if (type == 'memory') {
        // Marquer dans memory_queue
        final queue = _getMemoryQueue();
        final index = queue.indexWhere((item) => item['id'] == id);
        
        if (index != -1) {
          queue[index]['status'] = 'memorized';
          await _memBox?.put('memory_queue', queue);
        }
      } else {
        // Marquer dans retentions
        final retentions = _getRetentions();
        final index = retentions.indexWhere((item) => item['id'] == id);
        
        if (index != -1) {
          retentions[index]['poster_created'] = true;
          await _memBox?.put('retentions', retentions);
        }
      }
      
      print('‚úÖ Poster marqu√© comme cr√©√© pour $id');
    } catch (e) {
      print('‚ùå Erreur markPosterDone: $e');
    }
  }
  
  /// R√©cup√®re tous les versets m√©moris√©s
  /// 
  /// Retourne : Liste des versets marqu√©s comme m√©moris√©s
  static Future<List<Map<String, dynamic>>> getMemorizedVerses() async {
    final queue = _getMemoryQueue();
    return queue.where((item) => item['status'] == 'memorized').toList();
  }
  
  /// R√©cup√®re l'historique des r√©tentions
  /// 
  /// [limit] : Nombre maximum de r√©sultats (d√©faut: 30)
  /// 
  /// Retourne : Liste des r√©tentions r√©centes
  static Future<List<Map<String, dynamic>>> getRetentionHistory({int limit = 30}) async {
    final retentions = _getRetentions();
    
    // Trier par date (plus r√©cent en premier)
    retentions.sort((a, b) {
      final dateA = DateTime.parse(a['date'] as String);
      final dateB = DateTime.parse(b['date'] as String);
      return dateB.compareTo(dateA);
    });
    
    return retentions.take(limit).toList();
  }
  
  /// Supprime un √©l√©ment de la queue de m√©morisation
  static Future<void> removeFromMemoryQueue(String id) async {
    try {
      final queue = _getMemoryQueue();
      queue.removeWhere((item) => item['id'] == id);
      await _memBox?.put('memory_queue', queue);
      print('‚úÖ Verset $id retir√© de la queue');
    } catch (e) {
      print('‚ùå Erreur removeFromMemoryQueue: $e');
    }
  }
  
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // M√âTHODES PRIV√âES
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  
  /// R√©cup√®re la queue de m√©morisation
  static List<Map<String, dynamic>> _getMemoryQueue() {
    final raw = _memBox?.get('memory_queue');
    if (raw == null || raw is! List) return [];
    
    return raw.map((item) => Map<String, dynamic>.from(item as Map)).toList();
  }
  
  /// R√©cup√®re les r√©tentions
  static List<Map<String, dynamic>> _getRetentions() {
    final raw = _memBox?.get('retentions');
    if (raw == null || raw is! List) return [];
    
    return raw.map((item) => Map<String, dynamic>.from(item as Map)).toList();
  }
  
  /// üß† Sauvegarde dans le journal spirituel avec contexte enrichi
  static Future<void> _saveToJournal(
    String id, 
    String retained, 
    DateTime date, 
    Map<String, dynamic>? semantic, 
    String? thompson
  ) async {
    try {
      // TODO: Int√©grer avec MeditationJournalService
      print('üìî Sauvegard√© dans le journal avec contexte s√©mantique: $id');
    } catch (e) {
      print('‚ö†Ô∏è Erreur sauvegarde journal: $e');
    }
  }
  
  /// üß† Sauvegarde sur le mur spirituel avec contexte enrichi
  static Future<void> _saveToWall(
    String id, 
    String retained, 
    DateTime date, 
    Map<String, dynamic>? semantic, 
    String? thompson
  ) async {
    try {
      // TODO: Int√©grer avec SpiritualWallService
      print('üß± Publi√© sur le mur avec contexte Thompson: $id');
    } catch (e) {
      print('‚ö†Ô∏è Erreur sauvegarde mur: $e');
    }
  }

  /// üß† R√©cup√®re les suggestions intelligentes pour la m√©morisation
  static Future<List<Map<String, dynamic>>> getIntelligentSuggestions() async {
    try {
      final queue = _getMemoryQueue();
      final retentions = _getRetentions();
      
      // Trier par score de priorit√©
      queue.sort((a, b) {
        final scoreA = (a['priority_score'] as double?) ?? 0.0;
        final scoreB = (b['priority_score'] as double?) ?? 0.0;
        return scoreB.compareTo(scoreA);
      });
      
      // Analyser les r√©tentions pour des suggestions
      final suggestions = <Map<String, dynamic>>[];
      
      // Sugg√©rer des versets √† m√©moriser bas√©s sur les r√©tentions
      for (final retention in retentions.take(5)) {
        final spiritualDepth = retention['spiritual_depth'] as double? ?? 0.0;
        if (spiritualDepth > 0.7) {
          suggestions.add({
            'type': 'memorize_related',
            'id': retention['id'],
            'reason': 'R√©tention profonde - verset √† m√©moriser',
            'priority': 'high',
          });
        }
      }
      
      // Sugg√©rer des versets de la queue
      for (final item in queue.take(3)) {
        if (item['status'] == 'pending') {
          suggestions.add({
            'type': 'memorize_pending',
            'id': item['id'],
            'reason': 'En attente de m√©morisation',
            'priority': 'medium',
          });
        }
      }
      
      return suggestions;
    } catch (e) {
      print('‚ö†Ô∏è Erreur suggestions intelligentes: $e');
      return [];
    }
  }

  /// üß† Analyse les tendances de m√©morisation
  static Future<Map<String, dynamic>> getMemorizationTrends() async {
    try {
      final queue = _getMemoryQueue();
      final retentions = _getRetentions();
      
      // Analyser les th√®mes les plus m√©moris√©s
      final themeCounts = <String, int>{};
      final thompsonCounts = <String, int>{};
      
      for (final item in queue) {
        final semantic = item['semantic_context'] as Map<String, dynamic>?;
        final thompson = item['thompson_theme'] as String?;
        
        if (semantic != null) {
          final theme = semantic['theme'] as String?;
          if (theme != null) {
            themeCounts[theme] = (themeCounts[theme] ?? 0) + 1;
          }
        }
        
        if (thompson != null) {
          thompsonCounts[thompson] = (thompsonCounts[thompson] ?? 0) + 1;
        }
      }
      
      // Analyser les r√©tentions
      final emotionalTones = <String, int>{};
      final spiritualDepths = <double>[];
      
      for (final retention in retentions) {
        final tone = retention['emotional_tone'] as String?;
        final depth = retention['spiritual_depth'] as double?;
        
        if (tone != null) {
          emotionalTones[tone] = (emotionalTones[tone] ?? 0) + 1;
        }
        
        if (depth != null) {
          spiritualDepths.add(depth);
        }
      }
      
      return {
        'total_memorized': queue.where((item) => item['status'] == 'memorized').length,
        'total_pending': queue.where((item) => item['status'] == 'pending').length,
        'total_retentions': retentions.length,
        'popular_themes': themeCounts,
        'popular_thompson_themes': thompsonCounts,
        'emotional_tone_distribution': emotionalTones,
        'average_spiritual_depth': spiritualDepths.isNotEmpty 
            ? spiritualDepths.reduce((a, b) => a + b) / spiritualDepths.length 
            : 0.0,
        'most_retained_book': _getMostRetainedBook(retentions),
      };
    } catch (e) {
      print('‚ö†Ô∏è Erreur analyse tendances: $e');
      return {};
    }
  }

  /// üß† R√©cup√®re le livre le plus retenu
  static String _getMostRetainedBook(List<Map<String, dynamic>> retentions) {
    final bookCounts = <String, int>{};
    
    for (final retention in retentions) {
      final id = retention['id'] as String?;
      if (id != null) {
        final book = id.split('.').first;
        bookCounts[book] = (bookCounts[book] ?? 0) + 1;
      }
    }
    
    if (bookCounts.isEmpty) return 'Aucun';
    
    return bookCounts.entries
        .reduce((a, b) => a.value > b.value ? a : b)
        .key;
  }

  /// üß† Retourne les statistiques de m√©moire intelligente
  static Map<String, dynamic> getIntelligentStats() {
    return {
      'service_type': '√âvang√©liste Intelligent',
      'features': [
        'Analyse s√©mantique des passages',
        'Contexte Thompson enrichi',
        'Score de priorit√© intelligent',
        'Analyse √©motionnelle des r√©tentions',
        'Calcul de profondeur spirituelle',
        'Suggestions intelligentes',
        'Tendances de m√©morisation',
      ],
      'integrations': [
        'semantic_passage_boundary_service.dart (FALCON X)',
        'thompson_plan_service.dart (Thompson)',
        'meditation_journal_service.dart (Journal)',
      ],
    };
  }
}



